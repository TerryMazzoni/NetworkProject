{
    "selfIntroduction": "My name is Terry Mazzoni, I'm an EPITECH 4th year student in exchange at Dankook University. My principal hobbies are playing video games, watching animes and reading manhwa.",
    "lectures": [
        {
            "key": "chapter1",
            "label": "Chapter 1",
            "title": "🌐 Chapter 1: A Gentle Dive into the Internet and How It Works",
            "content": "Welcome to the Internet!\nThis chapter lays the foundation of how the Internet operates—both as a vast system of interconnected networks and as the digital plumbing behind the services we use every day.\n\n### 💡 What Is the Internet?\nAt its core, the Internet is a network of networks. It connects everything from your phone to vast data centers. Whether it's a social media app or an e-commerce platform, these services all run over a shared global infrastructure.\nThe Internet has two key views:\n- Nuts and bolts: A technical web of routers, switches, ISPs.\n- Service layer: A platform for applications—email, streaming, games, smart devices.\n\n### 📦 Protocols: The Rules of Communication\nA protocol is simply a set of rules that define how data is formatted and exchanged. Just like human conversations follow etiquette, machines use protocols like HTTP, TCP/IP, and Wi-Fi to communicate.\nProtocols ensure data is sent, received, and interpreted correctly across devices worldwide.\n\n### 🧭 The Internet's Architecture\nThe Internet can be broken down into several parts:\n###1. Network Edge\n- Hosts (end systems like laptops and servers) live at the edges.\n- Access Networks connect hosts to the Internet:\n - DSL, Cable, Fiber, Wi-Fi, 4G/5G.\n - Include home, enterprise, and data center networks.\n###2. Physical Media\n- Data travels through guided media (fiber, copper) or unguided (radio, wireless).\n- Performance depends on bandwidth and signal interference.\n###3. Network Core\n- Composed of routers and packet switches that forward data.\n- Uses packet switching: messages are broken into packets, stored, and forwarded hop-by-hop.\n\n### 🔄 Packet Switching vs. Circuit Switching\n- Packet switching: Efficient for bursty traffic, but can experience delays and losses during congestion.\n- Circuit switching: Reserves dedicated paths (like traditional telephony), guarantees performance, but underutilizes resources.\n\n### 📊 Network Performance Metrics\n- Delay: Comes from processing, queueing, transmission, and propagation.\n- Loss: Occurs when routers’ buffers overflow.\n- Throughput: Measures how fast data is delivered end-to-end.\nA fun analogy? Picture a caravan of cars at toll booths to imagine how delay and congestion happen!\n\n### 🔐 Network Security\nOriginally designed for trusted users, the Internet now faces serious threats:\n- Packet sniffing, IP spoofing, and Denial of Service (DoS) attacks.\n- Solutions: Encryption, Authentication, Firewalls, and Intrusion Detection Systems.\nSecurity is a constant concern—addressed in every layer of the protocol stack.\n\n### 🏗 Protocol Layers & Models\nThe Internet’s design is layered for clarity and modularity:\n1. Application – HTTP, SMTP\n2. Transport – TCP, UDP\n3. Network – IP, routing\n4. Link – Ethernet, Wi-Fi\n5. Physical – Bits on cables or radio waves\nEach layer builds on the one below and provides services to the one above.\nBonus: The OSI model adds two more layers—Presentation and Session—which are handled by apps in the Internet model.\n\n### 📜 A Brief History of the Internet\n- 1960s: Packet switching theory introduced.\n- 1969: First ARPANET node operational.\n- 1983: TCP/IP adopted, DNS introduced.\n- 1990s–2000s: Web explosion (HTML, HTTP, Mosaic browser).\n- 2005–Now: Rise of broadband, 4G/5G, SDN, cloud services, and mobile dominance.\n\n### 🎯 Final Thoughts\nChapter 1 provides a high-level tour through the essential concepts that make the Internet tick. From its layered design to real-world performance and historical roots, this foundation sets the stage for the deeper networking adventures ahead."
        },
        {
            "key": "chapter2",
            "label": "Chapter 2",
            "title": "🌐 Chapter 2: Understanding the Application Layer of the Internet",
            "content": "The application layer is where user-facing services live—think web browsers, email clients, and video streaming. This chapter explores both the principles behind network applications and the real-world protocols that power them.\n\n### 💡 Building a Network Application\nNetwork applications run on end systems, not routers. Developers use sockets—interfaces between apps and transport layers (like TCP/UDP)—to send and receive data across networks.\n\n### 🧱 Application Architectures\nTwo models dominate:\n- Client-Server: Servers always on, clients initiate contact. Examples: HTTP, IMAP.\n- Peer-to-Peer (P2P): End systems (peers) communicate directly. Examples: BitTorrent.\n\n### 📦 Sockets and Addressing\nA socket is like a door between an app and the network. To receive data, a process must have a unique IP address + port number combo.\n\n### 🧠 Application Layer Protocols\nProtocols define the messages, syntax, semantics, and rules for interaction. Examples include:\n- HTTP (web)\n- SMTP (email sending)\n- IMAP (email retrieval)\n- DNS (domain resolution)\nProtocols may be open (e.g., HTTP, DNS) or proprietary (e.g., Zoom).\n\n### 🚛 Transport Needs of Applications\nDifferent apps require different levels of:\n- Reliability (e.g., file transfer needs 100% accuracy)\n- Timing (e.g., VoIP needs low delay)\n- Throughput (e.g., video streaming needs steady rates)\n- Security (e.g., via TLS over TCP)\n\n### 🔁 TCP vs. UDP\n- TCP: Reliable, flow-controlled, congestion-controlled, connection-oriented. No timing guarantees.\n- UDP: Unreliable, no congestion control, but lightweight and fast. Used in real-time or loss-tolerant apps.\n\n### 🌐 HTTP in Action\n- Stateless: No memory of past requests\n- Non-persistent HTTP: New TCP connection per object\n- Persistent HTTP: Reuses one TCP connection\n- HTTP/2 & HTTP/3 (QUIC): Reduce delays, improve parallelism, support encryption\n\n### 🍪 Cookies & Web State\nHTTP is stateless, but cookies let servers remember users across sessions. Used for login sessions, preferences, and sometimes tracking behavior across sites—raising privacy concerns (e.g., GDPR).\n\n### 🗂 Web Caching\nCaches store previously fetched objects closer to the client to improve load times and reduce bandwidth. Local caches and proxy servers play a key role in efficiency.\n\n### 📬 Email: SMTP, IMAP\n- SMTP: Sends mail from client to server (push-based)\n- IMAP: Retrieves mail and manages folders (pull-based)\n- Email format defined by RFC 5321/2822; SMTP is ASCII-based and connection-oriented\n\n### 🌍 DNS: Naming the Internet\nThe Domain Name System (DNS) maps human-friendly names to IP addresses. It’s:\n- Hierarchical: Root servers → TLD servers → Authoritative servers\n- Distributed: Handles billions of queries per day\n- Resilient: With caching, redundancy, and security features (like DNSSEC)\n\n### 📺 Video Streaming and CDNs\nStreaming services (like Netflix) face two challenges: scalability and heterogeneity.\n- DASH: Breaks video into chunks, adapts to bandwidth in real time\n- CDNs: Content Delivery Networks place video files in servers near users for speed\n- QUIC and HTTP/3 aim to boost performance over UDP while maintaining reliability\n\n### 💻 Socket Programming\nThe chapter ends with real code—Python examples for building UDP and TCP client-server apps using sockets. You’ll see how to read from sockets, send/receive messages, and even handle timeouts with exception handling.\n\n### 🧠 Final Thoughts\nThe application layer is where Internet services are created and experienced. You now understand how web pages load, emails are delivered, video is streamed, and how developers actually code these services. Most importantly, you’ve seen how protocols tie everything together."
        },
        {
            "key": "chapter3",
            "label": "Chapter 3",
            "title": "🌐 Chapter 3: The Transport Layer – Delivering Data Reliably (and Fast)",
            "content": "The transport layer is the digital postman of the Internet. It ensures that messages from one process reach another—on time, in order, and without errors. This chapter explores its key responsibilities, protocols, and mechanisms.\n\n### 💡 Overview of the Transport Layer\nProvides logical communication between application processes on different hosts, building on the network layer's host-to-host delivery. Two protocols dominate:\n- TCP: Reliable, connection-oriented.\n- UDP: Lightweight, connectionless.\n\n### 🔗 Multiplexing and Demultiplexing\nMultiple applications can run on one host, so the transport layer uses port numbers and IP addresses to direct segments to the correct socket.\n- UDP demux: Uses only destination port.\n- TCP demux: Uses a 4-tuple (source/destination IP and port).\n\n### 📨 UDP: User Datagram Protocol\nA simple, fast, no-frills protocol:\n- No reliability, no ordering, no congestion control.\n- Used in apps where speed matters more than accuracy (e.g., video streaming, DNS, HTTP/3).\n- Error detection via checksums, but recovery is up to the app.\n\n### ✔️ Principles of Reliable Data Transfer\nReliability is built step-by-step with protocols like rdt1.0 (perfect channel), rdt2.0 (bit errors with ACK/NAK), and rdt3.0 (packet loss and timeout).\n- Uses finite state machines (FSMs) to handle sending, receiving, errors, and retransmissions.\n- Sequence numbers help detect duplicates.\n- Timers ensure lost packets get resent.\n\n### 🚀 Pipelining for Performance\nInstead of stop-and-wait, we use pipelining for better throughput:\n- Go-Back-N (GBN): Sender can send N packets without ACK. If one is lost, all after it are resent.\n- Selective Repeat (SR): More efficient—only unacknowledged packets are resent. Receiver buffers out-of-order packets.\n\n### 🔁 TCP: Transmission Control Protocol\nTCP is complex but powerful:\n- Reliable, in-order delivery of a byte stream.\n- Flow-controlled: prevents overwhelming the receiver.\n- Congestion-controlled: avoids choking the network.\n- Connection-oriented: uses a 3-way handshake to start.\n- Bi-directional (full duplex), stream-based (not message-based).\n\n### 📬 TCP Segment Structure\nEach TCP segment includes:\n- Sequence number, ACK number, window size, flags (SYN, FIN, ACK), and checksum.\n- MSS (Maximum Segment Size) defines how much data can be sent in one segment.\n\n### ⏱ TCP Timers and RTT Estimation\nReliable transfer needs dynamic timeout settings:\n- Uses SampleRTT, EstimatedRTT, and DevRTT to compute a safe timeout interval.\n- Avoids premature timeouts and improves efficiency.\n\n### 🕵️‍♂️ TCP Retransmissions\nHandles loss using:\n- Timeouts (retransmit after delay).\n- Duplicate ACKs (TCP fast retransmit).\n- Cumulative ACKs: Acknowledge all data up to a point, improving efficiency.\n\n### 🧠 TCP Flow Control\nTCP avoids overwhelming the receiver using rwnd (receiver window).\n- Receiver advertises available buffer space.\n- Sender ensures in-flight data ≤ advertised window.\n\n### 🤝 TCP Connection Management\n- Three-way handshake sets up connection with initial sequence numbers.\n- Graceful connection teardown: Each side sends FIN, waits for ACK.\n\n### 🌊 Principles of Congestion Control\nCongestion = too much data in the network.\n- Manifested as delay, packet loss, wasted retransmissions.\n- Control can be end-to-end (TCP infers congestion via loss/delay) or network-assisted (routers provide explicit feedback).\n\n### 📉 TCP Congestion Control (AIMD)\nTCP uses Additive Increase, Multiplicative Decrease (AIMD):\n- Slowly increases rate (probing bandwidth).\n- Halves sending rate when loss occurs.\n- Slow start doubles rate every RTT until threshold is hit.\n- Then switches to linear increase (congestion avoidance).\n\n### 📈 TCP Variants\n- TCP Reno and Tahoe use different strategies for loss recovery.\n- TCP CUBIC (Linux default) increases sending rate based on time since last congestion.\n- Delay-based TCP adjusts rate using RTT measurements.\n- ECN (Explicit Congestion Notification) lets routers signal congestion before loss.\n\n### ⚖️ TCP Fairness\nTCP aims to share bandwidth fairly among flows:\n- Parallel connections (e.g., browsers) can exploit fairness loopholes.\n- UDP apps may ignore congestion control—there's no 'Internet police' enforcing fairness.\n\n### 🚀 QUIC: The Future of Transport\nQUIC runs over UDP but provides TCP-like features:\n- Integrated security (TLS), multiplexing, and congestion control.\n- Faster connection setup (1-RTT), no head-of-line blocking.\n- Basis for HTTP/3, already deployed by major companies (e.g., Google).\n\n### 🧠 Final Thoughts\nThe transport layer is essential for ensuring your data arrives correctly, in order, and efficiently. Whether it’s sending a tweet or streaming a movie, TCP and UDP—and now QUIC—handle the complexity so you don’t have to."
        },
        {
            "key": "chapter4",
            "label": "Chapter 4",
            "title": "🌐 Chapter 4: The Network Layer (Data Plane) – Moving Packets Across the Internet",
            "content": "The network layer is where routers and IP addresses come into play. This chapter focuses on the data plane, the part of the network layer that moves packets through routers based on forwarding decisions.\n\n### 💡 The Role of the Network Layer\nResponsible for moving segments from the source host to the destination host across multiple networks. Core functions include:\n- Forwarding: Move packets to the correct outgoing link.\n- Routing: Determine the path from source to destination (covered in Chapter 5).\n\n### 🧠 Data Plane vs. Control Plane\n- Data Plane: Per-router logic that decides where each packet goes.\n- Control Plane: Network-wide logic that computes routing tables.\nTwo approaches:\n- Traditional routing (control inside routers).\n- Software-Defined Networking (SDN) (centralized control).\n\n### 🛣 Service Models and QoS\nThe Internet offers best-effort delivery: no guarantees on delay, order, or reliability.\nOther models (e.g., ATM) offer features like guaranteed bandwidth, delay, and order. QoS (Quality of Service) mechanisms can provide stronger guarantees at higher complexity.\n\n### 🧩 Inside a Router\nA router contains:\n- Input Ports: Receives packets, looks up forwarding decisions.\n- Switching Fabric: Moves packets between input/output.\n- Output Ports: Buffers packets and sends them.\nPerformance depends on the switch architecture (memory, bus, or crossbar-based).\n\n### 🔄 Forwarding and Longest Prefix Matching\nRouters use longest prefix matching to choose the best entry in the forwarding table for a packet’s destination address.\nHigh-speed lookups often use TCAMs (Ternary Content-Addressable Memory).\n\n### 🚦 Queuing and Buffering\n- Input Queuing: Happens when switch fabric is slower than incoming links.\n- Output Queuing: Occurs when multiple packets compete for the same outgoing link.\nProblems like Head-of-Line (HOL) blocking and buffer overflows can impact performance.\n\n### 🕒 Scheduling Policies\n- FIFO: First-in-first-out.\n- Priority Queuing: High-priority packets go first.\n- Round Robin: Fairly rotates through traffic classes.\n- Weighted Fair Queuing (WFQ): Allocates bandwidth proportionally across flows.\n\n### ⚖️ Network Neutrality\nDiscusses whether ISPs should treat all data equally. Debates center on:\n- No blocking lawful content.\n- No throttling traffic based on content type.\n- No paid prioritization of certain data flows.\nLaws vary by country and can affect packet scheduling.\n\n### 📦 The Internet Protocol (IP)\nIP is the glue of the network layer:\n- IPv4: 32-bit addresses, best-effort delivery.\n- IPv6: 128-bit addresses, no fragmentation, simplified headers, better for future growth.\n\n### 🧮 IP Addressing and Subnets\n- IP addresses consist of network and host parts.\n- Devices in the same subnet can reach each other directly.\n- CIDR (Classless Inter-Domain Routing) allows flexible subnetting (e.g., 192.0.2.0/24).\n- Hierarchical addressing enables route aggregation.\n\n### 🤝 DHCP: Getting an IP Address\nDHCP (Dynamic Host Configuration Protocol) assigns IPs dynamically:\n- Discovery → Offer → Request → ACK.\nAlso provides default gateway, DNS, and subnet mask.\n\n### 🔀 NAT: Network Address Translation\nNAT lets multiple devices share one public IP:\n- Translates internal IP/port to a unique external IP/port.\n- Maintains a NAT table.\n- Helps with IPv4 exhaustion but breaks end-to-end transparency.\n\n### 🚀 IPv6 and Transition\n- IPv6 solves address exhaustion with 128-bit addresses.\n- Removes fragmentation, simplifies headers.\n- Transition via tunneling (IPv6 inside IPv4) since not all routers are IPv6-ready.\n\n### 🧰 Generalized Forwarding and SDN\nModern routers use match + action:\n- Match packet fields (IP, port, etc.).\n- Apply actions: forward, drop, modify, etc.\nOpenFlow defines standardized flow tables for programmable networks.\n- Enables flexible policies (e.g., block SSH, reroute traffic).\n\n### 🧱 Middleboxes and Programmability\nMiddleboxes (e.g., firewalls, NATs, load balancers) perform non-standard router functions.\nTrends include:\n- Moving from hardware to software-based middleboxes.\n- SDN and NFV (Network Function Virtualization) allow centralized control and cloud-hosted services.\n\n### 🧠 Architectural Principles\nThe Internet follows the end-to-end principle:\n- Simplicity in the core, intelligence at the edge.\n- Protocol stack (IP at the waist) allows independent evolution above and below.\n\n### 🧠 Final Thoughts\nThe data plane enables every packet to reach its next hop, with decisions driven by IP headers, forwarding tables, and router architecture. Understanding this layer gives you a deep appreciation for how fast and reliably the Internet moves your data."
        },
        {
            "key": "chapter5",
            "label": "Chapter 5",
            "title": "🌐 Chapter 5: The Network Layer – Control Plane",
            "content": "The control plane is the brain behind routing decisions—determining how packets should traverse networks. This chapter explores traditional routing algorithms, software-defined networking, and real-world protocols like OSPF and BGP.\n\n### 💡 Two Approaches to Control\n- Per-router control: Each router runs its own routing algorithm.\n- Logically centralized control (SDN): A central controller installs forwarding tables in routers.\n\n### 🧠 Routing Protocol Goals\nFind “good” paths across a network—those with minimal cost, delay, or congestion. A key challenge in networking.\n\n### 📊 Link-State vs. Distance-Vector Algorithms\nRouting algorithms are categorized by the type of information they use and how they update routes:\n- Link-State (LS): Each router knows the full topology and link costs. Uses Dijkstra’s algorithm to compute shortest paths.\n- Distance-Vector (DV): Routers only share information with neighbors. Based on Bellman-Ford equation. Updates are iterative and asynchronous.\n\n### 🧮 Dijkstra’s Algorithm (LS)\n- Computes least-cost paths from a single node to all others.\n- All nodes broadcast their link-state info.\n- Routers independently build a complete view of the network.\n- Complexity: 𝑂(𝑛²), with improved implementations available.\n\n### 🔁 Bellman-Ford Algorithm (DV)\n- Each node sends its distance vector to neighbors.\n- Each node updates its own table using neighbor info.\n- Efficient and distributed, but can suffer from count-to-infinity problems.\n- Less overhead but slower convergence than LS.\n\n### ⚖️ Comparing LS and DV\n- LS: Global info, fast convergence, more computation, risk of bad link-state broadcasts.\n- DV: Simpler, scalable, but may loop or converge slowly.\n\n### 🌐 Intra-AS and Inter-AS Routing\n- Intra-AS: Routing within one autonomous system (AS). Common protocols:\n - RIP (obsolete), EIGRP, OSPF (link-state)\n- Inter-AS: Routing between ASes. Uses BGP (Border Gateway Protocol).\n\n### 📍 OSPF (Open Shortest Path First)\n- Each router floods link-state advertisements within the AS.\n- Runs Dijkstra’s algorithm to compute paths.\n- Authenticated updates, support for multiple metrics, and hierarchical areas for scalability.\n\n### 🛰 BGP: The Glue of the Internet\n- eBGP: Between different ASes.\n- iBGP: Within the same AS.\n- Uses path vector routing—routes consist of destination prefixes and attributes (e.g., AS-PATH, NEXT-HOP).\n- Allows routing based on policy, not just shortest path.\n\n### 🔥 Hot Potato Routing\nRouters may choose the closest exit point to another AS to minimize internal cost—even if it’s not the best inter-domain path.\n\n### 🧠 BGP Path Selection\nChooses routes using:\n- Local preference\n- Shortest AS path\n- NEXT-HOP proximity\n- Policy rules (e.g., only route for customers)\n\n### 🚧 Why Separate Intra- and Inter-AS Protocols?\n- Policy: Needed across ASes.\n- Scalability: Billions of destinations make routing table size and updates expensive.\n- Performance: Intra-AS can focus on speed; inter-AS focuses on control.\n\n### 🧠 Software Defined Networking (SDN)\nA new architecture for programmable networks:\n- Separates control plane from data plane.\n- Central SDN controller installs flow rules via OpenFlow.\n- Enables fine-grained traffic engineering, rapid innovation, and cloud-scale control.\n\n### 🛠 SDN Controller Architecture\n- Northbound API: For apps (e.g., routing, security).\n- Southbound API: Talks to switches (e.g., OpenFlow).\n- Distributed control: Ensures scalability, resilience.\n\n### 💡 OpenFlow Basics\nOpen standard protocol for SDN:\n- Controller-to-switch: Install, modify, delete flow entries.\n- Switch-to-controller: Notify controller about events.\n- Flow entries use match + action logic (e.g., match IP, forward on port).\n\n### 🚦 SDN in Practice: Google ORION, ODL, ONOS\n- ORION: Google’s SDN platform for data centers and WAN.\n- OpenDaylight (ODL) and ONOS: Community-driven SDN controllers with modular architectures and RESTful APIs.\n\n### 📢 ICMP (Internet Control Message Protocol)\nUsed by routers and hosts to report errors:\n- Carries control messages like ping (echo request/reply), unreachable host, TTL expired.\n- Helps tools like traceroute map the Internet path.\n\n### 🛠 Network Management: SNMP & NETCONF\nNetworks must be monitored and configured efficiently:\n- SNMP: Query/update Management Information Base (MIB) on devices.\n- NETCONF/YANG: XML-based protocol and data modeling language for structured, transactional network configuration.\n- Offers operations like <get-config>, <edit-config>, <subscribe>, and validation via YANG.\n\n### 🧠 Final Thoughts\nThis chapter reveals the intelligence behind network routing. From Dijkstra and Bellman-Ford to BGP and SDN, the control plane determines how the Internet dynamically adapts to traffic, policy, and failure—quietly keeping your data flowing."
        },
        {
            "key": "chapter6",
            "label": "Chapter 6",
            "title": "🌐 Chapter 6: The Link Layer – Connecting Adjacent Devices",
            "content": "The link layer is responsible for delivering data between directly connected nodes. From error detection to Ethernet switches and VLANs, this chapter covers how local networks operate and how frames move within them.\n\n### 💡 Introduction to the Link Layer\nThe link layer connects adjacent nodes in a communication path. It operates over wired or wireless links and uses frames to encapsulate network-layer datagrams.\nEach link may use a different protocol (e.g., Ethernet, Wi-Fi), and not all provide the same services.\n\n### 🚗 Transportation Analogy\nA datagram's journey is like a multi-leg trip:\n- Each transport mode = link-layer protocol\n- Travel agent = routing algorithm\n- Each segment = individual link\n\n### 🧰 Link Layer Services\n- Framing and link access: Encapsulate datagram in a frame.\n- Link addressing: Use MAC addresses.\n- Reliable delivery: Usually not used in Ethernet (used in Wi-Fi).\n- Flow control, error detection, error correction, duplex modes.\n\n### 💻 Host Link-Layer Implementation\nImplemented in the network interface card (NIC)—hardware + software that handles framing, error checks, and access protocols.\n\n### 🧪 Error Detection and Correction\n- Parity bits: Simple error detection.\n- Checksums: Used in UDP/TCP/IP headers.\n- Cyclic Redundancy Check (CRC): Common in Ethernet/Wi-Fi; detects burst errors with high accuracy.\n\n### 📡 Multiple Access Protocols\nFor shared links (e.g., wireless, old Ethernet):\n- Channel partitioning: TDMA, FDMA.\n- Random access: ALOHA, CSMA, CSMA/CD.\n- Taking turns: Polling, token passing.\nEach approach balances fairness, efficiency, and complexity.\n\n### 🔀 MAC Protocols in Practice\n- Slotted ALOHA: Sync required; 37% max efficiency.\n- Pure ALOHA: Simpler, only ~18% efficiency.\n- CSMA/CD: Used in wired Ethernet (now rare).\n- CSMA/CA: Used in wireless LANs (802.11).\n\n### 🧍‍♂️ MAC Addresses & ARP\n- MAC address: 48-bit, unique to each NIC.\n- ARP (Address Resolution Protocol): Maps IP to MAC within a subnet. Uses broadcast requests and replies.\n\n### 🚏 Addressing Across Subnets\n- IP datagram must be encapsulated in a frame with destination MAC.\n- If destination is in another subnet, frame is sent to the router’s MAC.\n- At each hop, new link-layer frame is created.\n\n### 📦 Ethernet\n- Most widely used wired LAN technology.\n- Frame structure includes preamble, source/destination MAC, type, payload, CRC.\n- Unreliable, connectionless—no ACKs at link layer.\n- Ethernet MAC uses CSMA/CD with binary backoff.\n\n### 🔁 Ethernet Switches\n- Store-and-forward devices that learn MAC addresses.\n- Use a switching table to forward selectively, else flood.\n- Support full duplex, no collisions.\n- Can interconnect switches for large-scale LANs.\n\n### 🧠 Switch vs. Router\n- Switch: Layer 2, uses MAC addresses.\n- Router: Layer 3, uses IP addresses and routing algorithms.\n\n### 🏷 VLANs: Virtual LANs\n- Logically partition a LAN into multiple broadcast domains.\n- Port-based VLANs: Assign switch ports to specific VLANs.\n- 802.1Q tagging: Adds VLAN ID to Ethernet frames.\n- Trunk ports: Carry frames across VLANs between switches.\n\n### 🌐 Link Virtualization with MPLS\n- MPLS (Multiprotocol Label Switching): Adds a label to packets for fast forwarding.\n- Used in backbone networks for traffic engineering, load balancing, and fast rerouting.\n- More efficient than IP prefix matching, and supports policy-based routing.\n\n### 🏢 Data Center Networks\n- High-density environments with thousands of servers.\n- Use top-of-rack switches, tiered architectures, and load balancers.\n- Innovations like ECN, RDMA over Ethernet, and SDN improve speed, reliability, and scalability.\n\n### 🔄 A Day in the Life of a Web Request\nPuts everything together:\n- DHCP assigns IP.\n- ARP resolves MAC.\n- DNS maps domain to IP.\n- TCP connects to server.\n- HTTP requests and responses traverse multiple layers.\nLink layer handles each frame hop-by-hop, quietly ensuring everything works under the hood.\n\n### 🧠 Final Thoughts\nThe link layer makes local delivery possible. Whether it's error detection, media access, or MAC addressing, this layer underpins Ethernet, Wi-Fi, VLANs, and even virtualized networking like MPLS—keeping your packets on track at every hop."
        },
        {
            "key": "chapter7",
            "label": "Chapter 7",
            "title": "Chapter 7",
            "content": "TBC"
        },
        {
            "key": "chapter8",
            "label": "Chapter 8",
            "title": "Chapter 8",
            "content": "TBC"
        }
    ]
}
